package de.rwth.idsg.steve.css.v12;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.List;

import javax.annotation.Resource;
import javax.xml.ws.WebServiceContext;
import javax.xml.ws.handler.MessageContext;

import org.apache.cxf.ws.addressing.AddressingProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.rwth.idsg.steve.common.Utils;


/**
 * This class was generated by Apache CXF 2.3.1
 * Mon Jul 29 22:10:30 CEST 2013
 * Generated source version: 2.3.1
 *  
 */
@javax.jws.WebService(
		serviceName = "CentralSystemService",
		portName = "CentralSystemServiceSoap12",
		targetNamespace = "urn://Ocpp/Cs/2010/08/",
		wsdlLocation = "file:/Users/sgokay/Documents/Eclipse Workspace/mano/WebContent/centralsystemservice_0.wsdl",
		endpointInterface = "de.rwth.idsg.steve.css.v12.CentralSystemService")

public class CentralSystemServiceImpl implements CentralSystemService {
	@Resource
	private WebServiceContext webServiceContext;

	private static final Logger LOG = LoggerFactory.getLogger(CentralSystemServiceImpl.class);

	// Heartbeat interval in seconds
	private static final int HEARTBEAT_INTERVAL = 7200;
	// Determines how many hours the idtag should be stored in the local whitelist of a chargebox
	private static final int HOURS_TO_EXPIRE = 1;

	public BootNotificationResponse bootNotification(BootNotificationRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation bootNotification");

		MessageContext messageContext = webServiceContext.getMessageContext();
		AddressingProperties addressProp = (AddressingProperties) messageContext.get(org.apache.cxf.ws.addressing.JAXWSAConstants.SERVER_ADDRESSING_PROPERTIES_INBOUND);
		String endpoint_address = addressProp.getFrom().getAddress().getValue();

		Connection connect = null;
		PreparedStatement pt = null;
		BootNotificationResponse _return = null;
		try {	
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			connect.setAutoCommit(false);

			// One DB call with two functions:
			//
			// 1. Update all fields with the exception of chargeBoxId, so that initially it is enough to register 
			// a chargebox with its ID in DB. During boot, the chargebox provides missing information which might be updated (for ex: firmware)
			//
			// 2. If the chargebox not registered => no chargeboxes to update => updated/returned row count = 0
			pt = connect.prepareStatement("UPDATE chargebox SET endpoint_address=?, chargePointVendor=?, chargePointModel=?,"
					+ "chargePointSerialNumber=?, chargeBoxSerialNumber=?, fwVersion=?, "
					+ "iccid=?, imsi=?, meterType=?, meterSerialNumber=? WHERE chargeBoxId = ?");

			// Set the parameter indices
			pt.setString(1, endpoint_address);
			pt.setString(2, parameters.getChargePointVendor());
			pt.setString(3, parameters.getChargePointModel());
			pt.setString(4, parameters.getChargePointSerialNumber());
			pt.setString(5, parameters.getChargeBoxSerialNumber());
			pt.setString(6, parameters.getFirmwareVersion());
			pt.setString(7, parameters.getIccid());
			pt.setString(8, parameters.getImsi());
			pt.setString(9, parameters.getMeterType());
			pt.setString(10, parameters.getMeterSerialNumber());
			pt.setString(11, chargeBoxIdentity);

			// Execute the SQL query
			int count = pt.executeUpdate();
			
			// Set the response message fields
			_return = new BootNotificationResponse();
			RegistrationStatus _returnStatus = null;
			
			// Validate the change
			if (count == 1) {
				connect.commit();
				LOG.info("The chargebox " + chargeBoxIdentity + " is registered and its boot acknowledged.");
				_returnStatus = RegistrationStatus.ACCEPTED;
				_return.setCurrentTime(Utils.getCurrentDateTimeXML());
				_return.setHeartbeatInterval(Integer.valueOf(HEARTBEAT_INTERVAL));
				
			} else {
				LOG.error("Transaction is being rolled back.");
				connect.rollback();
				LOG.error("The chargebox " + chargeBoxIdentity + " is not registered and its boot not acknowledged.");
				_returnStatus = RegistrationStatus.REJECTED;
			}
			connect.setAutoCommit(true);
			_return.setStatus(_returnStatus);			
		} catch (SQLException e1) {
			e1.printStackTrace();		
		} finally {
			Utils.releaseResources(connect, pt, null);
		}					
		return _return;
	}

	public FirmwareStatusNotificationResponse firmwareStatusNotification(FirmwareStatusNotificationRequest parameters, java.lang.String chargeBoxIdentity) {
		LOG.info("Executing operation firmwareStatusNotification");	

		Connection connect = null;
		PreparedStatement pt = null;		
		try {		
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			connect.setAutoCommit(false);

			// PreparedStatements can use parameter indices as question marks
			pt = connect.prepareStatement("UPDATE chargebox SET fwUpdateStatus = ?, fwUpdateTimestamp = ? WHERE chargeBoxId = ?");

			// Set the parameter indices
			String status = parameters.getStatus().toString();
			pt.setString(1, status);
			pt.setTimestamp(2, Utils.getCurrentDateTimeTS());
			pt.setString(3, chargeBoxIdentity);

			// Update the Firmware Status of the Chargebox with the new one
			int count = pt.executeUpdate();			
			// Validate the change
			if (count == 1) {
				connect.commit();
			} else {
				LOG.error("Transaction is being rolled back.");
				connect.rollback();
			}
			connect.setAutoCommit(true);
		} catch (SQLException e1) {
			e1.printStackTrace();
		} finally {
			Utils.releaseResources(connect, pt, null);
		}		

		// Send the return message to the Chargebox
		FirmwareStatusNotificationResponse _return = new FirmwareStatusNotificationResponse();
		return _return;
	}

	public StatusNotificationResponse statusNotification(StatusNotificationRequest parameters, java.lang.String chargeBoxIdentity) {
		LOG.info("Executing operation statusNotification");

		Connection connect = null;
		PreparedStatement pt = null;
		try { 
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Since we are doing two inserts
			connect.setAutoCommit(false);

			// For the first boot of the chargebox: Insert its connectors in DB
			// For next boots: IGNORE.
			pt = connect.prepareStatement("INSERT IGNORE INTO connector (chargeBoxId, connectorId) VALUES (?,?)");

			// Set the parameter indices  
			pt.setString(1, chargeBoxIdentity);
			pt.setInt(2, parameters.getConnectorId()); 
			// Insert the new status
			int count = pt.executeUpdate();
			// Validate the change
			if (count >= 1) {
				LOG.info("This NEW connector of the chargebox is inserted into DB.");
			}else{
				LOG.info("This connector of the chargebox is ALREADY known to DB.");
			}

			Utils.releaseResources(null, pt, null);

			// We store a log of connector statuses with their timestamps.
			pt = connect.prepareStatement("INSERT INTO connector_status (connector_pk, status, statusTimestamp, errorCode) "
					+ "SELECT connector_pk , ? , ? , ? FROM connector WHERE chargeBoxId = ? AND connectorId = ?");

			// Set the parameter indices             
			pt.setString(1, parameters.getStatus().toString());
			pt.setTimestamp(2, Utils.getCurrentDateTimeTS());
			pt.setString(3, parameters.getErrorCode().toString());         
			pt.setString(4, chargeBoxIdentity);
			pt.setInt(5, parameters.getConnectorId()); 

			// Insert the new status
			count = pt.executeUpdate();	
			// Validate the change
			if (count >= 1) {
				// Now we can commit everything
				connect.commit();
			} else {
				LOG.error("Transaction is being rolled back.");
				connect.rollback();
			}
			connect.setAutoCommit(true);
		} catch (SQLException e1) {
			e1.printStackTrace();
		} finally {
			Utils.releaseResources(connect, pt, null);
		}
		
		StatusNotificationResponse _return = new StatusNotificationResponse();
		return _return;
	}

	public MeterValuesResponse meterValues(MeterValuesRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation meterValues");

		Connection connect = null;
		PreparedStatement pt = null;	
		try {
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Disable the auto commit since we are making multiple updates. By default, it is always true.
			connect.setAutoCommit(false);
			// We store a log of connector meter values with their timestamps.
			pt = connect.prepareStatement("INSERT INTO connector_metervalue (connector_pk, value, valueTimestamp) "
					+ "SELECT connector_pk , ? , ? FROM connector WHERE chargeBoxId = ? AND connectorId = ?");

			// Set the parameter indices for batch execution
			List<MeterValue> meterValues = parameters.getValues();
			for(MeterValue temp : meterValues){
				pt.setInt(1, temp.getValue());
				pt.setTimestamp(2, Utils.convertToTimestamp(temp.getTimestamp()));					
				pt.setString(3, chargeBoxIdentity);
				pt.setInt(4, parameters.getConnectorId());
				pt.addBatch();
			}

			// Execute the batch.
			int[] count = pt.executeBatch();
			// Validate the change
			if (Utils.validateDMLChanges(count)) {
				// Now we can commit everything
				connect.commit();
			} else {
				LOG.error("Transaction is being rolled back.");
				connect.rollback();
			}
			connect.setAutoCommit(true);
		} catch (SQLException e1) {
			e1.printStackTrace();
		}  finally {
			Utils.releaseResources(connect, pt, null);
		}
		
		MeterValuesResponse _return = new MeterValuesResponse();
		return _return;
	}

	public DiagnosticsStatusNotificationResponse diagnosticsStatusNotification(DiagnosticsStatusNotificationRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation diagnosticsStatusNotification");

		Connection connect = null;
		PreparedStatement pt = null;
		try {
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			connect.setAutoCommit(false);
			// PreparedStatements can use parameter indices as question marks
			pt = connect.prepareStatement("UPDATE chargebox SET diagnosticsStatus = ?, diagnosticsTimestamp = ? WHERE chargeBoxId = ?");
			// Set the parameter indices
			pt.setString(1, parameters.getStatus().toString());
			pt.setTimestamp(2, Utils.getCurrentDateTimeTS());
			pt.setString(3, chargeBoxIdentity);
			// Perform update
			int count = pt.executeUpdate();
			// Validate the change
			if (count == 1) {
				connect.commit();
			} else {
				LOG.error("Transaction is being rolled back.");
				connect.rollback();
			}
			connect.setAutoCommit(true);
		} catch (SQLException e1) {
			e1.printStackTrace();
		}  finally {
			Utils.releaseResources(connect, pt, null);
		}
		
		DiagnosticsStatusNotificationResponse _return = new DiagnosticsStatusNotificationResponse();
		return _return;
	}

	public AuthorizeResponse authorize(AuthorizeRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation authorize");

		Connection connect = Utils.getConnectionFromPool();
		IdTagInfo _returnIdTagInfo = this.authorizeInternal(connect, parameters.getIdTag());
		Utils.releaseResources(connect, null, null);

		AuthorizeResponse _return = new AuthorizeResponse();
		_return.setIdTagInfo(_returnIdTagInfo);
		return _return;
	}

	public HeartbeatResponse heartbeat(HeartbeatRequest parameters,java.lang.String chargeBoxIdentity) {	
		LOG.info("Executing operation heartbeat");

		HeartbeatResponse _return = new HeartbeatResponse();
		_return.setCurrentTime(Utils.getCurrentDateTimeXML());
		return _return;
	}

	public StopTransactionResponse stopTransaction(StopTransactionRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation stopTransaction");

		Connection connect = null;
		PreparedStatement pt = null;
		try {			
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Disable the auto commit. By default, it is always true.
			connect.setAutoCommit(false);

			// PreparedStatements can use parameter indices as question marks
			// After update, a DB trigger sets the user.inTransaction field to 0
			pt = connect.prepareStatement("UPDATE transaction SET stopTimestamp = ?, stopValue = ? WHERE transaction_pk = ?");

			// Set the parameter indices
			pt.setTimestamp(1, Utils.convertToTimestamp(parameters.getTimestamp()));
			pt.setInt(2, parameters.getMeterStop());				
			pt.setInt(3, parameters.getTransactionId());

			// Insert the transaction into DB
			int count = pt.executeUpdate();
			// Validate the change
			if (count == 1) {
				// Now we can commit
				connect.commit();
			} else {
				LOG.error("Transaction is being rolled back.");
				connect.rollback();
			}
			connect.setAutoCommit(true);
		} catch (SQLException e1) {
			e1.printStackTrace();
		} finally {
			// Release only PreparedStatement. Connection will be used in the next step.
			Utils.releaseResources(null, pt, null);	
		}
		
		// Get the authorization info of the user
		StopTransactionResponse _return = new StopTransactionResponse();
		String idTag = parameters.getIdTag();
		if (idTag != null) {
			IdTagInfo _returnIdTagInfo = this.authorizeInternal(connect, idTag);
			_return.setIdTagInfo(_returnIdTagInfo);
		}
		// Now we can release the Connection. 
		Utils.releaseResources(connect, null, null);	
		return _return;
	}

	public StartTransactionResponse startTransaction(StartTransactionRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation startTransaction");

		Connection connect = null;
		StartTransactionResponse _return = new StartTransactionResponse();
		String idTag = parameters.getIdTag();
		try {
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Get the authorization info of the user
			IdTagInfo _returnIdTagInfo = this.authorizeInternal(connect, idTag);

			// If authorized, update the transactions table
			if (_returnIdTagInfo.getStatus() == AuthorizationStatus.ACCEPTED) {
				// Disable the auto commit. By default, it is always true.
				connect.setAutoCommit(false);

				// PreparedStatements can use parameter indices as question marks
				// After insert, a DB trigger sets the user.inTransaction field to 1
				PreparedStatement pt = connect.prepareStatement("INSERT INTO transaction (connector_pk, idTag, startTimestamp, startValue) "
						+ "SELECT connector_pk , ? , ? , ? FROM connector WHERE chargeBoxId = ? AND connectorId = ?", PreparedStatement.RETURN_GENERATED_KEYS);

				// Set the parameter indices
				pt.setString(1, idTag);
				pt.setTimestamp(2, Utils.convertToTimestamp(parameters.getTimestamp()));
				pt.setInt(3, parameters.getMeterStart());				
				pt.setString(4, chargeBoxIdentity);
				pt.setInt(5, parameters.getConnectorId());

				// Insert the transaction into DB
				int count = pt.executeUpdate();
				
				// Get the generated key in order to obtain the auto-incremented transaction_id
				ResultSet rs = pt.getGeneratedKeys();	
				if (rs.next()) {
					_return.setTransactionId( rs.getInt(1) ); // transaction_pk is the 1. column
				}
				
				// Validate the change
				if (count == 1) {
					// Now we can commit
					connect.commit();
				} else {
					LOG.error("Transaction is being rolled back.");
					connect.rollback();
				}
				connect.setAutoCommit(true);
				Utils.releaseResources(null, pt, rs);
			}
			_return.setIdTagInfo(_returnIdTagInfo);	

		} catch (SQLException e1) {
			e1.printStackTrace();
		} finally {
			Utils.releaseResources(connect, null, null);
		}
		return _return;
	}


	/**
	 * Helper method to query the authorization of an idTag.
	 */
	private IdTagInfo authorizeInternal(Connection connect, String idTag) {
		
		PreparedStatement pt = null;
		ResultSet rs = null;
		IdTagInfo _returnIdTagInfo = new IdTagInfo();
		try {
			// PreparedStatements can use parameter indices as question marks
			pt = connect.prepareStatement("SELECT parentIdTag, expiryDate, inTransaction, blocked FROM user WHERE idTag = ?");
			// Set the parameter indices
			pt.setString(1, idTag);
			// Execute and get the result of the SQL query
			rs = pt.executeQuery();

			AuthorizationStatus _returnIdTagInfoStatus = null;
			
			if (rs.next() == false) {
				// Id is not in DB (unknown id). Not allowed for charging.
				_returnIdTagInfoStatus = AuthorizationStatus.INVALID;
				LOG.info("The idTag of this user is INVALID (not present in DB).");
			} else {			
				// Read the DB row values
				String parentIdTag = rs.getString(1);
				Timestamp expiryDate = rs.getTimestamp(2);
				boolean inTransaction = rs.getBoolean(3);
				boolean blocked = rs.getBoolean(4);

				if (inTransaction == true) {
					_returnIdTagInfoStatus = AuthorizationStatus.CONCURRENT_TX;
					LOG.info("The idTag of this user is ALREADY in another transaction.");
				} else if (blocked == true) {
					_returnIdTagInfoStatus = AuthorizationStatus.BLOCKED;
					LOG.info("The idTag of this user is BLOCKED.");
				} else if (expiryDate != null && Utils.getCurrentDateTimeTS().after(expiryDate)) {
					_returnIdTagInfoStatus = AuthorizationStatus.EXPIRED;
					LOG.info("The idTag of this user is EXPIRED.");
				} else {
					_returnIdTagInfoStatus = AuthorizationStatus.ACCEPTED;
					// When accepted, set the additional fields
					_returnIdTagInfo.setExpiryDate(Utils.setExpiryDateTime(HOURS_TO_EXPIRE));
					if ( parentIdTag!=null ) _returnIdTagInfo.setParentIdTag(parentIdTag);
					LOG.info("The idTag of this user is ACCEPTED.");
				}
			}
			_returnIdTagInfo.setStatus(_returnIdTagInfoStatus);	
			
		} catch (SQLException e1) {
			e1.printStackTrace();
		} finally {
			Utils.releaseResources(null, pt, rs);
		}
		return _returnIdTagInfo;
	}
}