package css;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Timestamp;
import java.util.List;

import javax.annotation.Resource;
import javax.xml.ws.WebServiceContext;
import javax.xml.ws.handler.MessageContext;

import org.apache.cxf.ws.addressing.AddressingProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import common.Utils;


/**
 * This class was generated by Apache CXF 2.3.1
 * Mon Jul 29 22:10:30 CEST 2013
 * Generated source version: 2.3.1
 *  
 */
@javax.jws.WebService(
		serviceName = "CentralSystemService",
		portName = "CentralSystemServiceSoap12",
		targetNamespace = "urn://Ocpp/Cs/2010/08/",
		wsdlLocation = "file:/Users/sgokay/Documents/Eclipse Workspace/mano/WebContent/centralsystemservice_0.wsdl",
		endpointInterface = "css.CentralSystemService")

public class CentralSystemServiceImpl implements CentralSystemService {
	@Resource
	private WebServiceContext webServiceContext;

	private static final Logger LOG = LoggerFactory.getLogger(CentralSystemServiceImpl.class);

	// Heartbeat interval in seconds
	private static final int HEARTBEAT_INTERVAL = 7200;
	// Determines how many hours the idtag should be stored in the local whitelist of a chargebox
	private static final int HOURS_TO_EXPIRE = 1;

	public css.BootNotificationResponse bootNotification(BootNotificationRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation bootNotification");

		MessageContext messageContext = webServiceContext.getMessageContext();
		AddressingProperties addressProp = (AddressingProperties) messageContext.get(org.apache.cxf.ws.addressing.JAXWSAConstants.SERVER_ADDRESSING_PROPERTIES_INBOUND);
		String endpoint_address = addressProp.getFrom().getAddress().getValue();

		Connection connect = null;
		PreparedStatement pt = null;
		try {	
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			connect.setAutoCommit(false);

			// One DB call with two functions:
			//
			// 1. Update all fields with the exception of chargeBoxId, so that initially it is enough to register 
			// a chargebox with its ID in DB. During boot, the chargebox provides missing information which might be updated (for ex: firmware)
			//
			// 2. If the chargebox not registered => no chargeboxes to update => updated/returned row count = 0
			pt = connect.prepareStatement("UPDATE chargebox SET endpoint_address=?, chargePointVendor=?, chargePointModel=?,"
					+ "chargePointSerialNumber=?, chargeBoxSerialNumber=?, fwVersion=?, "
					+ "iccid=?, imsi=?, meterType=?, meterSerialNumber=? WHERE chargeBoxId = ?");

			// Set the parameter indices
			pt.setString(1, endpoint_address);
			pt.setString(2, parameters.getChargePointVendor());
			pt.setString(3, parameters.getChargePointModel());
			pt.setString(4, parameters.getChargePointSerialNumber());
			pt.setString(5, parameters.getChargeBoxSerialNumber());
			pt.setString(6, parameters.getFirmwareVersion());
			pt.setString(7, parameters.getIccid());
			pt.setString(8, parameters.getImsi());
			pt.setString(9, parameters.getMeterType());
			pt.setString(10, parameters.getMeterSerialNumber());
			pt.setString(11, chargeBoxIdentity);

			// Execute and get the result of the SQL query
			int count = pt.executeUpdate();
			connect.commit();

			// Set the response message fields
			BootNotificationResponse _return = new BootNotificationResponse();
			RegistrationStatus _returnStatus = null;

			if ( count==1 ) {
				LOG.info("The chargebox " + chargeBoxIdentity + " is registered and its boot acknowledged.");
				_returnStatus = RegistrationStatus.ACCEPTED;
				_return.setCurrentTime(Utils.getCurrentDateTimeXML());
				_return.setHeartbeatInterval(Integer.valueOf(HEARTBEAT_INTERVAL));
			}else{
				LOG.error("The chargebox " + chargeBoxIdentity + " is not registered and its boot not acknowledged.");
				_returnStatus = RegistrationStatus.REJECTED;		
			}

			_return.setStatus(_returnStatus);			
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			Utils.releaseResources(connect, pt, null);
		}
	}

	public css.FirmwareStatusNotificationResponse firmwareStatusNotification(FirmwareStatusNotificationRequest parameters, java.lang.String chargeBoxIdentity) {
		LOG.info("Executing operation firmwareStatusNotification");	

		Connection connect = null;
		PreparedStatement pt = null;		
		try {		
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			connect.setAutoCommit(false);

			// PreparedStatements can use parameter indices as question marks
			pt = connect.prepareStatement("UPDATE chargebox SET fwUpdateStatus = ?, fwUpdateTimestamp = ? WHERE chargeBoxId = ?");

			// Set the parameter indices
			String status = parameters.getStatus().toString();
			pt.setString(1, status);
			pt.setTimestamp(2, Utils.getCurrentDateTimeTS());
			pt.setString(3, chargeBoxIdentity);

			// Update the Firmware Status of the Chargebox with the new one
			int count = pt.executeUpdate();
			Utils.validateDMLChanges(count);
			connect.commit();

			// Send the return message to the Chargebox
			FirmwareStatusNotificationResponse _return = new FirmwareStatusNotificationResponse();
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			Utils.releaseResources(connect, pt, null);
		}
	}

	public css.StatusNotificationResponse statusNotification(StatusNotificationRequest parameters, java.lang.String chargeBoxIdentity) {
		LOG.info("Executing operation statusNotification");

		Connection connect = null;
		PreparedStatement pt = null;
		try { 
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Since we are doing two inserts
			connect.setAutoCommit(false);

			// For the first boot of the chargebox: Insert its connectors in DB
			// For next boots: IGNORE.
			pt = connect.prepareStatement("INSERT IGNORE INTO connector (chargeBoxId, connectorId) VALUES (?,?)");

			// Set the parameter indices  
			pt.setString(1, chargeBoxIdentity);
			pt.setInt(2, parameters.getConnectorId()); 
			// Insert the new status
			int count = pt.executeUpdate();
			// Validate the change
			if (count>=1) {
				LOG.info("This NEW connector of the chargebox is inserted into DB.");
			}else{
				LOG.info("This connector of the chargebox is ALREADY known to DB.");
			}

			Utils.releaseResources(null, pt, null);

			// We store a log of connector statuses with their timestamps.
			pt = connect.prepareStatement("INSERT INTO connector_status (connector_pk, status, statusTimestamp, errorCode) "
					+ "SELECT connector_pk , ? , ? , ? FROM connector WHERE chargeBoxId = ? AND connectorId = ?");

			// Set the parameter indices             
			pt.setString(1, parameters.getStatus().toString());
			pt.setTimestamp(2, Utils.getCurrentDateTimeTS());
			pt.setString(3, parameters.getErrorCode().toString());         
			pt.setString(4, chargeBoxIdentity);
			pt.setInt(5, parameters.getConnectorId()); 

			// Insert the new status
			count = pt.executeUpdate();
			// Validate the change
			Utils.validateDMLChanges(count);
			// Now we can commit
			connect.commit();

			StatusNotificationResponse _return = new StatusNotificationResponse();
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			Utils.releaseResources(connect, pt, null);
		}
	}

	public css.MeterValuesResponse meterValues(MeterValuesRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation meterValues");

		Connection connect = null;
		PreparedStatement pt = null;	
		try {
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Disable the auto commit since we are making multiple updates. By default, it is always true.
			connect.setAutoCommit(false);
			// We store a log of connector meter values with their timestamps.
			pt = connect.prepareStatement("INSERT INTO connector_metervalue (connector_pk, value, valueTimestamp) "
					+ "SELECT connector_pk , ? , ? FROM connector WHERE chargeBoxId = ? AND connectorId = ?");

			// Set the parameter indices for batch execution
			List<MeterValue> meterValues = parameters.getValues();
			for(MeterValue temp : meterValues){
				pt.setInt(1, temp.getValue());
				pt.setTimestamp(2, Utils.convertToTimestamp(temp.getTimestamp()));					
				pt.setString(3, chargeBoxIdentity);
				pt.setInt(4, parameters.getConnectorId());
				pt.addBatch();
			}

			// Execute the batch.
			pt.executeBatch();
			connect.commit();

			MeterValuesResponse _return = new MeterValuesResponse();
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}  finally {
			Utils.releaseResources(connect, pt, null);
		}
	}

	public css.DiagnosticsStatusNotificationResponse diagnosticsStatusNotification(DiagnosticsStatusNotificationRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation diagnosticsStatusNotification");

		Connection connect = null;
		PreparedStatement pt = null;
		try {
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			connect.setAutoCommit(false);
			// PreparedStatements can use parameter indices as question marks
			pt = connect.prepareStatement("UPDATE chargebox SET diagnosticsStatus = ?, diagnosticsTimestamp = ? WHERE chargeBoxId = ?");
			// Set the parameter indices
			pt.setString(1, parameters.getStatus().toString());
			pt.setTimestamp(2, Utils.getCurrentDateTimeTS());
			pt.setString(3, chargeBoxIdentity);
			// Perform update
			int count = pt.executeUpdate();

			// Validate the change
			if( Utils.validateDMLChanges(count) ) {
				LOG.info("diagnoticsStatus for" + chargeBoxIdentity + " is updated.");
				connect.commit();
			}else{
				connect.rollback();
			}

			DiagnosticsStatusNotificationResponse _return = new DiagnosticsStatusNotificationResponse();
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}  finally {
			Utils.releaseResources(connect, pt, null);
		}
	}

	public css.AuthorizeResponse authorize(AuthorizeRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation authorize");

		Connection connect = null;
		try {
			connect = Utils.getConnectionFromPool();
			IdTagInfo _returnIdTagInfo = this.authorizeInternal(connect, parameters.getIdTag());
			Utils.releaseResources(connect, null, null);

			AuthorizeResponse _return = new AuthorizeResponse();
			_return.setIdTagInfo(_returnIdTagInfo);
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}
	}

	public css.HeartbeatResponse heartbeat(HeartbeatRequest parameters,java.lang.String chargeBoxIdentity) {	
		LOG.info("Executing operation heartbeat");
		try {	
			HeartbeatResponse _return = new HeartbeatResponse();
			_return.setCurrentTime(Utils.getCurrentDateTimeXML());
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}
	}

	public css.StopTransactionResponse stopTransaction(StopTransactionRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation stopTransaction");

		Connection connect = null;

		try {			
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Disable the auto commit since upcoming SQL queries are part of one action. By default, it is always true.
			connect.setAutoCommit(false);

			// PreparedStatements can use parameter indices as question marks
			// After update, a trigger sets the user.inTransaction field to 0
			PreparedStatement pt = connect.prepareStatement("UPDATE transaction SET stopTimestamp = ?, stopValue = ? WHERE transaction_pk = ?");

			// Set the parameter indices
			pt.setTimestamp(1, Utils.convertToTimestamp(parameters.getTimestamp()));
			pt.setInt(2, parameters.getMeterStop());				
			pt.setInt(3, parameters.getTransactionId());

			// Insert the transaction into DB
			int count = pt.executeUpdate();

			// Validate the change
			Utils.validateDMLChanges(count);

			Utils.releaseResources(null, pt, null);

			// Get the authorization info of the user
			IdTagInfo _returnIdTagInfo = null;
			StopTransactionResponse _return = new StopTransactionResponse();
			String idTag = parameters.getIdTag();
			if( idTag!=null ) {
				_returnIdTagInfo = this.authorizeInternal(connect, idTag);
				_return.setIdTagInfo(_returnIdTagInfo);
			}

			// Now we can commit
			connect.commit();
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			Utils.releaseResources(connect, null, null);
		}
	}

	public css.StartTransactionResponse startTransaction(StartTransactionRequest parameters,java.lang.String chargeBoxIdentity) { 
		LOG.info("Executing operation startTransaction");

		Connection connect = null;
		StartTransactionResponse _return = null;
		String idTag = parameters.getIdTag();

		try {
			// Prepare Database Access
			connect = Utils.getConnectionFromPool();
			// Disable the auto commit since upcoming SQL queries are part of one action. By default, it is always true.
			connect.setAutoCommit(false);
			// Get the authorization info of the user
			IdTagInfo _returnIdTagInfo = this.authorizeInternal(connect, idTag);

			// If authorized, update the transactions table
			// After insert, a trigger sets the user.inTransaction field to 1
			if(_returnIdTagInfo.getStatus() == AuthorizationStatus.ACCEPTED){

				// PreparedStatements can use parameter indices as question marks
				PreparedStatement pt = connect.prepareStatement("INSERT INTO transaction (connector_pk, idTag, startTimestamp, startValue) "
						+ "SELECT connector_pk , ? , ? , ? FROM connector WHERE chargeBoxId = ? AND connectorId = ?", PreparedStatement.RETURN_GENERATED_KEYS);

				// Set the parameter indices
				pt.setString(1, idTag);
				pt.setTimestamp(2, Utils.convertToTimestamp(parameters.getTimestamp()));
				pt.setInt(3, parameters.getMeterStart());				
				pt.setString(4, chargeBoxIdentity);
				pt.setInt(5, parameters.getConnectorId());

				// Insert the transaction into DB
				pt.executeUpdate();
				// Get the generated key in order to obtain the auto-incremented transaction_id
				ResultSet rs = pt.getGeneratedKeys();

				// Commit the changes if execution was successful		
				_return = new StartTransactionResponse();	
				if (rs.next()) {
					_return.setTransactionId( rs.getInt(1) ); // transaction_pk is the 1. column
					connect.commit();
				}else {
					connect.rollback();
				}
				Utils.releaseResources(null, pt, rs);
			}

			_return.setIdTagInfo(_returnIdTagInfo);
			return _return;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			Utils.releaseResources(connect, null, null);
		}
	}


	/**
	 * Helper method to query the authorization of an idTag.
	 */
	private css.IdTagInfo authorizeInternal(Connection connect, String idTag) {
		PreparedStatement pt = null;
		ResultSet rs = null;		
		try {
			// PreparedStatements can use parameter indices as question marks
			pt = connect.prepareStatement("SELECT parentIdTag, expiryDate, inTransaction, blocked FROM user WHERE idTag = ?");
			// Set the parameter indices
			pt.setString(1, idTag);
			// Execute and get the result of the SQL query
			rs = pt.executeQuery();

			IdTagInfo _returnIdTagInfo = new IdTagInfo();
			AuthorizationStatus _returnIdTagInfoStatus = null;

			if ( rs.next()==false ){
				// Id is not in DB (unknown id). Not allowed for charging.
				_returnIdTagInfoStatus = AuthorizationStatus.INVALID;
				LOG.info("The idTag of this user is INVALID (not present in DB).");
			}else{			
				// Read the DB row values
				String parentIdTag = rs.getString(1);
				Timestamp expiryDate = rs.getTimestamp(2);
				boolean inTransaction = rs.getBoolean(3);
				boolean blocked = rs.getBoolean(4);

				if ( inTransaction==true ){
					_returnIdTagInfoStatus = AuthorizationStatus.CONCURRENT_TX;
					LOG.info("The idTag of this user is ALREADY in another transaction.");
				}else if ( blocked==true ){
					_returnIdTagInfoStatus = AuthorizationStatus.BLOCKED;
					LOG.info("The idTag of this user is BLOCKED.");
				}else if ( expiryDate!=null && Utils.getCurrentDateTimeTS().after(expiryDate) ){
					_returnIdTagInfoStatus = AuthorizationStatus.EXPIRED;
					LOG.info("The idTag of this user is EXPIRED.");
				}else{
					_returnIdTagInfoStatus = AuthorizationStatus.ACCEPTED;
					// When accepted, set the additional fields
					_returnIdTagInfo.setExpiryDate(Utils.setExpiryDateTime(HOURS_TO_EXPIRE));
					if ( parentIdTag!=null ) _returnIdTagInfo.setParentIdTag(parentIdTag);
					LOG.info("The idTag of this user is ACCEPTED.");
				}
			}

			_returnIdTagInfo.setStatus(_returnIdTagInfoStatus);		
			return _returnIdTagInfo;
		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			Utils.releaseResources(null, pt, rs);
		}
	}
}